# LogiTrax API – Build Guide & System Overview

This README documents how to recreate the LogiTrax API from scratch. It covers the initial business logic and database integration (Activity 1), the development of RESTful API endpoints (Activity 2), and the implementation of secure authentication with JWT and role‑based authorization (Activity 3). 

Each section details not only the original planned steps but also the modifications made to enhance the design.

---

## Table of Contents
1. [Activity 1: Structuring Business Logic and Database Integration]
2. [Activity 2: Building RESTful API Endpoints]
3. [Activity 3: JWT Authentication & Securing the API]
4. [Activity 4: Optimizing Performance with Caching and Copilot]
5. [Activity 5: Strengthening Security with ASP.NET Identity and JWT]

---

## Activity 1: Structuring Business Logic and Database Integration

<details>
<summary>Click to expand</summary>

### 1. Project Setup
- Open Visual Studio Code.
- Create a new ASP.NET Core Web API project using the CLI:  
  ```bash
  dotnet new webapi -n LogiTrax
  ```
- Create a **Models** folder and add two new class files:  
  - `InventoryItem.cs`  
  - `Order.cs`

### 2. Define the Core Models
- In `InventoryItem.cs`, define a product with properties such as:
  - `ItemId`, `Name`, `Quantity`, and `Location`.
- Implement a `DisplayInfo()` method in `InventoryItem.cs`:  
  Example: `[ Item: GamePal | Quantity: 12 | Location: Warehouse A ]`
- In `Order.cs`, define an order with properties like:
  - `OrderId`, `CustomerName`, `DatePlaced`, and a list to hold ordered items.
- Test these models in a sample block of code (in `Program.cs` or a dedicated test controller).

### 3. Database Integration with EF Core
- Add EF Core packages via NuGet:  
  ```bash
  dotnet add package Microsoft.EntityFrameworkCore.Sqlite
  dotnet add package Microsoft.EntityFrameworkCore.Tools
  ```
- Create the `LogiTraxContext.cs` file to establish a connection to a SQLite database and configure the model relationships.

### Modifications and Enhancements Made
- Identified design issues with the original `Order` model that directly held a list of `InventoryItem` objects, leading to duplicate key conflicts and foreign key constraint issues.
- **Improvement:** Introduced a new entity, `OrderItem.cs`, to hold references to `InventoryItem` by ID along with the ordered quantity. Updated `Order.cs` to include a list of `OrderItem` objects.
- Updated `LogiTraxContext.cs` to define proper relationships and cascade delete rules between `InventoryItem`, `Order`, and `OrderItem`.

### Submission Checklist
1. Two working classes: `InventoryItem` and `Order`.
2. Test data with basic output shown in the console or controller.
3. `LogiTraxContext` with EF Core integration.
4. Database successfully created and tested.
5. Copilot-assisted review applied.

</details>

---

## Activity 2: Building RESTful API Endpoints

<details>
<summary>Click to expand</summary>

### 1. Creating the Controllers
- In the **Controllers** folder, create two controller files:  
  - `InventoryController.cs`  
  - `OrderController.cs`

### 2. Developing Inventory Endpoints
- In `InventoryController.cs`, implement endpoints for:
  - `GET /api/inventory` to return all inventory items.
  - `POST /api/inventory` to add a new inventory item.
  - `DELETE /api/inventory/{id}` to remove an inventory item.
- Use dependency injection to access `LogiTraxContext.cs`.

### 3. Developing Order Endpoints
- In `OrderController.cs`, implement endpoints for:
  - `GET /api/orders` to list all orders.
  - `GET /api/orders/{id}` to return the full details of a specific order.
  - `POST /api/orders` to create a new order (accepting a JSON payload with customer name, date placed, and an array of order items including inventoryItem IDs and quantities).
  - `DELETE /api/orders/{id}` to remove an order.

### 4. Endpoint Testing
- Test these endpoints using Swagger or Postman to verify that the inventory and orders are created and persisted as expected.

### Modifications and Enhancements Made
- Enhanced order operations to verify stock availability, subtract ordered quantities, and create orders with associated `OrderItem` records.
- Implemented inventory cleanup endpoint in `InventoryController.cs` to consolidate duplicate or orphaned inventory records.
- Applied Copilot suggestions to improve error handling, asynchronous operations, and route design.

### Submission Checklist
1. Two API Controllers: `InventoryController` and `OrderController`.
2. Working `GET`, `POST`, `DELETE` routes for both controllers.
3. Routes tested in Swagger or Postman.
4. Microsoft Copilot suggestions applied.

</details>

---

## Activity 3: JWT Authentication & Securing the API

<details>
<summary>Click to expand</summary>

### 1. Configuring ASP.NET Identity and JWT
- Register ASP.NET Identity services using a custom user model (e.g., `ApplicationUser`).
- Configure EF Core to work with Identity.
- Set up JWT authentication in `Program.cs`, including validation parameters (issuer, audience, secret), and specify claim mapping (NameClaimType and RoleClaimType).
- Configure necessary JWT settings in `appsettings.json`.

### 2. Implementing Authentication Endpoints
- Create `AuthController.cs` with:
  - A registration endpoint (`POST /api/auth/register`) for new user creation.
  - A login endpoint (`POST /api/auth/login`) that authenticates the user and generates a JWT token with role claims.

### 3. Securing Endpoints
- Secure specific endpoints using `[Authorize(Roles = "Manager")]`.

### Submission Checklist
1. ASP.NET Identity installed and configured.
2. `ApplicationUser` model created.
3. Registration and login routes added.
4. JWT token-based authentication implemented.
5. Routes secured with `[Authorize]` and roles.
6. Copilot suggestions reviewed and applied.

</details>

---

## Activity 4: Optimizing Performance with Caching and Copilot

<details>
<summary>Click to expand</summary>

### 1. Enable In-Memory Caching
- Register caching in `Program.cs` using `builder.Services.AddMemoryCache()`.

### 2. Cache Frequently Accessed Data
- Modify the `GET` endpoint in `InventoryController` to first check for a cached inventory list.
- If the cache key is not found, query the database and store the result in the cache with an expiration.

### 3. Analyze and Optimize Queries
- Use `.Include()` and `.ThenInclude()` to eager-load related data.
- Use `.AsNoTracking()` for read-only queries.

### Submission Checklist
1. In-memory caching implemented on at least one route.
2. Query optimizations applied in controller logic.
3. Cache expiration policy in place.
4. Copilot prompts used to refine logic.

</details>

---

## Activity 5: Strengthening Security with ASP.NET Identity and JWT

<details>
<summary>Click to expand</summary>

### 1. ASP.NET Identity Configuration
- Integrated ASP.NET Identity by extending the DbContext from `IdentityDbContext<ApplicationUser>`.

### 2. User Model and Authentication Endpoints
- Created the `ApplicationUser` model inheriting from `IdentityUser`.
- Developed `AuthController` with endpoints for user registration and login.

### 3. JWT Token Generation
- Configured JWT settings and ensured tokens include user identity and role claims.

### Submission Checklist
1. ASP.NET Identity configured and operational.
2. Registration and login routes added and tested.
3. JWT token-based authentication implemented.
4. Routes secured with `[Authorize]` and role restrictions.

</details>

---

Following this guide will allow anyone to recreate the LogiTrax API from scratch with a robust, modern, and secure architecture.

